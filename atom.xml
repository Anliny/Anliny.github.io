<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>卓代丰的博客</title>
  
  
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-21T03:15:46.798Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>anliny</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue打印部分网页和预览生成PDF</title>
    <link href="http://yoursite.com/2020/05/21/vue%E6%89%93%E5%8D%B0%E9%83%A8%E5%88%86%E7%BD%91%E9%A1%B5%E5%92%8C%E9%A2%84%E8%A7%88%E7%94%9F%E6%88%90PDF/"/>
    <id>http://yoursite.com/2020/05/21/vue%E6%89%93%E5%8D%B0%E9%83%A8%E5%88%86%E7%BD%91%E9%A1%B5%E5%92%8C%E9%A2%84%E8%A7%88%E7%94%9F%E6%88%90PDF/</id>
    <published>2020-05-20T16:00:00.000Z</published>
    <updated>2020-05-21T03:15:46.798Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说明</p></blockquote><p>前几天做项目，根据需求根据项目展示数据并打印出来，我们项目使用的是VUE库。在网上查找了各种资料，试了各种操作，终于找到了满意的答案。这里记录一下，分享一下心得。<br>首先需要说明的是我们项目使用的是Vue全家桶。<br>这里需要安装一个插件  vue-print-nb </p><blockquote><p>安装</p></blockquote><p>npm 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-print-nb --save</span><br></pre></td></tr></table></figure><p> yarn 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vue-print-nb</span><br></pre></td></tr></table></figure><blockquote><p>使用</p></blockquote><p>安装好后，在<code>main.js</code>中引入,然后用<code>vue.use(Print)</code>引入，就可以全局使用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imprt xxxxxx</span><br><span class="line">import Print from &#39;vue-print-nb&#39;</span><br><span class="line">vue.use(Print)</span><br></pre></td></tr></table></figure><blockquote><p>打印页面需要的内容</p></blockquote><p>上面步骤操作完过后，我们就要规定打印的内容了<br>在你要打印的页面中，在要打印的最外层包裹层中规定一个ID,<code>id=&quot;printTest&quot;</code>,我这里示例打印的是一个表格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;printTest&quot;</span><br><span class="line">    style&#x3D;&quot;width:774px;padding:10px&quot;&gt;</span><br><span class="line">    &lt;Table stripe</span><br><span class="line">            :columns&#x3D;&quot;columns1&quot;</span><br><span class="line">            :data&#x3D;&quot;data1&quot;&gt;</span><br><span class="line">    &lt;&#x2F;Table&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>然后在触发打印预览的按钮上，写入指令<code>v-print=&quot;&#39;#printTest&#39;&quot;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button v-print&#x3D;&quot;&#39;#printTest&#39;&quot;&gt;打印v-print&lt;&#x2F;Button&gt;</span><br></pre></td></tr></table></figure><p>这样我们就能在浏览器上面预览  <code>pad</code>文件了，最主要的是如果数据过多他会自动分页，哈哈，还是挺好的！</p><blockquote><p>预览效果</p></blockquote><p>打印预览<br><img src="/2020/05/21/vue%E6%89%93%E5%8D%B0%E9%83%A8%E5%88%86%E7%BD%91%E9%A1%B5%E5%92%8C%E9%A2%84%E8%A7%88%E7%94%9F%E6%88%90PDF/02.jpg" alt><br>如果预览满意，下面有个打印按钮。这样我们就可以打印啦</p><blockquote><p>关于样式</p></blockquote><ul><li>这个插件可以直接设置css样式进行设置要打印的内容 我的示例是用的<code>iview</code>ui库。</li><li>如果我们打印的是A4纸大小的话，全屏样式在A4纸上显示不全， 这个时候我们需要将内容设置成A4纸大小，打印内容宽度设置为<code>width：794px</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;printTest&quot;</span><br><span class="line">    style&#x3D;&quot;width:774px;padding:10px&quot;&gt;打印内容&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>其他 </p></blockquote><p>最近还有一个需求就是打印PDF文件，我想用这个方法也是可行的。完美规避两个问题。</p><blockquote><p>感谢</p></blockquote><p>简书   smartdream  <a href="https://www.jianshu.com/p/a240a0c44c17" target="_blank" rel="noopener">https://www.jianshu.com/p/a240a0c44c17</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前几天做项目，根据需求根据项目展示数据并打印出来，我们项目使用的是VUE库。在网上查找了各种资料，试了各种操作，终于找到了满意的答案。这里记录一下，分享一下心得。&lt;br&gt;首先需要说明的是我们项目使用的
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>vue - 面试常用总结</title>
    <link href="http://yoursite.com/2020/04/13/vue%E7%AF%87/"/>
    <id>http://yoursite.com/2020/04/13/vue%E7%AF%87/</id>
    <published>2020-04-12T16:00:00.000Z</published>
    <updated>2020-04-13T10:14:34.332Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>vue通信</p></blockquote><ul><li>props、$emit()、refs</li><li>中央事件总线 EventBus(基本不用)</li><li>Vuex (官方推荐状态管理器)</li><li>$parent和$children</li></ul><blockquote><p>说说Vue原理</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue 是采用数据劫持配合发布者-订阅者模式，通过Object.defineProperty()来劫持各个属性的setTer()和getter(),</span><br><span class="line">在数据变化的时候，发布消息给依赖收集器，去通知观察者，去通知回调函数做出视图更新。</span><br></pre></td></tr></table></figure><blockquote><p>Vue 路由守卫有哪些，怎么设置，使用场景</p></blockquote><p>常用的两个路由守卫：router.beforeEach 和 router.afterEach<br>每个守卫方法接收三个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">to: Route: 即将要进入的目标 路由对象</span><br><span class="line">from: Route: 当前导航正要离开的路由</span><br><span class="line">next: Function: 一定要调用该方法来 resolve 这个钩子。</span><br></pre></td></tr></table></figure><p>在项目中，一般在beforeEach这个钩子函数中进行路由跳转的一些信息判断。<br>判断是否登录，是否拿到对应的路由权限等等。</p><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;vue通信&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;props、$emit()、refs&lt;/li&gt;
&lt;li&gt;中央事件总线 EventBus(基本不用)&lt;/li&gt;
&lt;li&gt;Vuex (官方推荐状态管理器)&lt;/li&gt;
&lt;li&gt;$paren
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>面试常用总结 - javascript</title>
    <link href="http://yoursite.com/2020/04/05/javascript%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://yoursite.com/2020/04/05/javascript%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2020-04-13T03:46:18.819Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说一说js是什么语言</p></blockquote><p>javascript 是一种直译性脚本语言，是一种具备动态类型，弱类型，基于原型的语言。<br>它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。</p><h2 id="介绍promise-Promise有几个状态"><a href="#介绍promise-Promise有几个状态" class="headerlink" title="介绍promise,Promise有几个状态"></a>介绍promise,Promise有几个状态</h2><p>promise 主要解决异步编程的一种方案，比传统的解决方案–回调函数和事件–更合理和强大。<br>他是一个对象， 用来处理异步操作，可以让我在写异步调用的时候看起来更加优雅便于阅读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sleep(ms) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        setTimeout(resolve, ms);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">sleep(500).then( ()&#x3D;&gt; console.log(&quot;finished&quot;));</span><br></pre></td></tr></table></figure><p>promise分为三种状态 进行中、已成功、已失败</p><ul><li>Pending状态（进行中）</li><li>Fulfilled状态（已成功）</li><li>Rejected状态（已失败）</li></ul><h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p>ES7中引入了async和await这种方式能够彻底告别执行器和生成器。<br>async是一个通过异步执行并隐世返回一个Promise作为结果的函数。async是Generator的语法糖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const foo &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">    let response1 &#x3D; await fetch(&#39;https:&#x2F;&#x2F;xxx&#39;) </span><br><span class="line">    console.log(&#39;response1&#39;)</span><br><span class="line">    console.log(response1)</span><br><span class="line">    let response2 &#x3D; await fetch(&#39;https:&#x2F;&#x2F;xxx&#39;) </span><br><span class="line">    console.log(&#39;response2&#39;)</span><br><span class="line">    console.log(response2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="call、apply和find的区别"><a href="#call、apply和find的区别" class="headerlink" title="call、apply和find的区别"></a>call、apply和find的区别</h4><p>call、apply、bind 都是用来改变this指向。</p><ul><li>call方法<br>call方法第一个参数是要绑定给this的值，后面传入的参数是一个列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 3, 89, 46]</span><br><span class="line">var max &#x3D; Math.max.call(null, arr[0], arr[1], arr[2], arr[3], arr[4])&#x2F;&#x2F;89</span><br></pre></td></tr></table></figure>eg: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    message: &#39;My name is: &#39;</span><br><span class="line">&#125;</span><br><span class="line">function getName(firstName, lastName) &#123;</span><br><span class="line">    console.log(this.message + firstName + &#39; &#39; + lastName)</span><br><span class="line">&#125;</span><br><span class="line">getName.call(obj, &#39;Dot&#39;, &#39;Dolby&#39;)</span><br></pre></td></tr></table></figure></li><li>apply方法<br>apply接受两个参数，第一个参数是要绑定给this的值，第二个参数是一个数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1,2,3,89,46]</span><br><span class="line">var max &#x3D; Math.max.apply(null,arr)&#x2F;&#x2F;89</span><br></pre></td></tr></table></figure>eg:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    message: &#39;My name is: &#39;</span><br><span class="line">&#125;</span><br><span class="line">function getName(firstName, lastName) &#123;</span><br><span class="line">    console.log(this.message + firstName + &#39; &#39; + lastName)</span><br><span class="line">&#125;</span><br><span class="line">getName.apply(obj, [&#39;Dot&#39;, &#39;Dolby&#39;])&#x2F;&#x2F; My name is: Dot Dolby</span><br></pre></td></tr></table></figure></li><li>bind方法<br>bind 方法的用法和 call 非常相似，第一个参数是this指向，第二参数是参数列表，不同的是定义变量的形式接收bind方法的返回,bind方法不会立即执行，需要调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn(a, b, c) &#123;</span><br><span class="line">    console.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line">var fn1 &#x3D; fn.bind(null, &#39;Dot&#39;);</span><br><span class="line">fn(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;);            &#x2F;&#x2F; A B C</span><br><span class="line">fn1(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;);           &#x2F;&#x2F; Dot A B</span><br><span class="line">fn1(&#39;B&#39;, &#39;C&#39;);                &#x2F;&#x2F; Dot B C</span><br><span class="line">fn.call(null, &#39;Dot&#39;);</span><br></pre></td></tr></table></figure><h2 id="面试烧脑题"><a href="#面试烧脑题" class="headerlink" title="面试烧脑题"></a>面试烧脑题</h2></li><li>var a={}, b={name:’b’}, c={name:’c’}; a[b]=123; a[c]=456; console.log(a[b]);//为什么是456？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;&#123;&#125;, b&#x3D;&#39;123&#39;, c&#x3D;123;  </span><br><span class="line">a[b]&#x3D;&#39;b&#39;;</span><br><span class="line">a[c]&#x3D;&#39;c&#39;;  </span><br><span class="line">console.log(a[b]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 因为键名称只能是字符串，b&#x2F;c单做键会调用toString得到的都是[object Object]，a[b],a[c]都等价于a[&quot;[object Object]&quot;]，那不就是更新[object Object]这个键的值了</span><br></pre></td></tr></table></figure></li></ul><h2 id="选择前3个元素"><a href="#选择前3个元素" class="headerlink" title="选择前3个元素"></a>选择前3个元素</h2><p>渲染列表时，需要设置前3个元素的margin-top值与其他的不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:nth-child(-n+3)&#123;</span><br><span class="line">     margin-top: 12px;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody><tr><td><code>site</code></td><td>Sitewide information.</td></tr><tr><td><code>page</code></td><td>Page specific information and custom variables set in front-matter.</td></tr><tr><td><code>config</code></td><td>Site configuration</td></tr><tr><td><code>theme</code></td><td>Theme configuration. Inherits from site configuration.</td></tr><tr><td><code>_</code> (single underscore)</td><td><a href="http://lodash.com/" target="_blank" rel="noopener">Lodash</a> library</td></tr><tr><td><code>path</code></td><td>Path of current page</td></tr><tr><td><code>url</code></td><td>Full URL of current page</td></tr><tr><td><code>env</code></td><td>Environment variables</td></tr></tbody></table><h2 id="语法比较"><a href="#语法比较" class="headerlink" title="语法比较"></a>语法比较</h2><div class="note">    <h5>测试标题</h5>    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。</p></div><h4 id="Map-语法"><a href="#Map-语法" class="headerlink" title="Map 语法"></a>Map 语法</h4><p>下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-map: (</span><br><span class="line">    small: (</span><br><span class="line">        min-width: null,</span><br><span class="line">        max-width: 479px,</span><br><span class="line">        base-font: 16px,</span><br><span class="line">        vertical-rhythm: 1.3</span><br><span class="line">    ),</span><br><span class="line">    medium: (</span><br><span class="line">        min-width: 480px,</span><br><span class="line">        max-width: 959px,</span><br><span class="line">        base-font: 18px,</span><br><span class="line">        vertical-rhythm: 1.414</span><br><span class="line">    ),</span><br><span class="line">    large: (</span><br><span class="line">        min-width: 960px,</span><br><span class="line">        max-width: 1099px,</span><br><span class="line">        base-font: 18px,</span><br><span class="line">        vertical-rhythm: 1.5</span><br><span class="line">    ),</span><br><span class="line">    xlarge: (</span><br><span class="line">        min-width: 1100px,</span><br><span class="line">        max-width: null,</span><br><span class="line">        base-font: 21px,</span><br><span class="line">        vertical-rhythm: 1.618</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="多重列表语法"><a href="#多重列表语法" class="headerlink" title="多重列表语法"></a>多重列表语法</h4><p>下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 <code>nth()</code> 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-list: (</span><br><span class="line">    (small, null, 479px, 16px, 1.3),</span><br><span class="line">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class="line">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class="line">    (xlarge, 1100px, null, 21px, 1.618)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="遍历比较"><a href="#遍历比较" class="headerlink" title="遍历比较"></a>遍历比较</h2><div class="note info">    <h5>测试标题</h5>    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p></div><h4 id="遍历-Map"><a href="#遍历-Map" class="headerlink" title="遍历 Map"></a>遍历 Map</h4><p>我们可以使用如下的代码遍历 Map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $map in $breakpoint-map &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里的变量 <code>$label</code> 和 <code>$map</code> 会随着对 <code>$breakpoint-map</code> 的遍历被动态地赋值，<code>$label</code> 将会被赋值为 <code>$breakpoint-map</code> 的 Key，而 <code>$map</code> 会被赋值为 <code>$breakpoint-map</code> 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 <code>map-get()</code> 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。</p><p>具体的做法就是使用 <code>@each</code> 遍历 Map，然后使用 <code>map-get()</code> 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $map in $breakpoint-map &#123;</span><br><span class="line">    $min-width: map-get($map, min-width);</span><br><span class="line">    $max-width: map-get($map, max-width);</span><br><span class="line">    $base-font: map-get($map, base-font);</span><br><span class="line">    $vertical-rhythm: map-get($map, vertical-rhythm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历多重列表"><a href="#遍历多重列表" class="headerlink" title="遍历多重列表"></a>遍历多重列表</h4><p>遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 <code>map-get()</code> 函数取特定值，直接遍历一遍即可获得特定值。</p><p>因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 <code>map-get()</code>，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="慎用多重列表"><a href="#慎用多重列表" class="headerlink" title="慎用多重列表"></a>慎用多重列表</h2><div class="note warning">    <h5>测试标题</h5>    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p></div><h4 id="遗漏键值"><a href="#遗漏键值" class="headerlink" title="遗漏键值"></a>遗漏键值</h4><p>如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-list: (</span><br><span class="line">    (small, null, 479px, 16px, 1.3),</span><br><span class="line">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class="line">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class="line">    (xlarge, 1100px, 21px, 1.618)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class="line">        @if $min-width &#123;</span><br><span class="line">            @include breakpoint( $min-width ) &#123;</span><br><span class="line">                font-size: $base-font;</span><br><span class="line">                line-height: $vertical-rhythm;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; @else &#123;</span><br><span class="line">            font-size: $base-font;</span><br><span class="line">            line-height: $vertical-rhythm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们尝试运行这段代码时，结果肯定是错误地，因为在 <code>$breakpoint-list</code> 的最后一行，<code>xlarge</code> 被赋值给了 <code>$label</code>，<code>1100px</code> 被赋值给了 <code>$min-width</code>，<code>21px</code> 被赋值给了 <code>$max-width</code>, <code>1.618</code> 被赋值给了 <code>$base-font</code>，最终导致 <code>$vertical-rhythm</code> 没有被赋值，结果就是 <code>font-size</code> 的属性值是错的，<code>line-height</code> 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。</p><p>如果我们使用 Map 来代替这里的多重列表，那么使用 <code>map-get()</code> 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。</p><h4 id="查找特定列表"><a href="#查找特定列表" class="headerlink" title="查找特定列表"></a>查找特定列表</h4><p>在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 <code>map-get()</code> 函数可以快速定位到特定子 Map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$medium-map: map-get($maps, medium);</span><br></pre></td></tr></table></figure><p>但如果要获取多种列表 <code>medium</code> 列表，麻烦可就大了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@function get-list($label) &#123;</span><br><span class="line">    @each $list in $breakpoint-list &#123;</span><br><span class="line">        @if nth($list, 1) &#x3D;&#x3D; $label &#123;</span><br><span class="line">            @return $list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @return null;</span><br><span class="line">&#125;</span><br><span class="line">$medium-list: get-list(medium);</span><br></pre></td></tr></table></figure><p>这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 <code>null</code>。这实际上就是手工实现了 <code>map-get()</code> 的逻辑。</p><h4 id="缺少原生的-Map-函数"><a href="#缺少原生的-Map-函数" class="headerlink" title="缺少原生的 Map 函数"></a>缺少原生的 Map 函数</h4><p>Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 <code>map-merge()</code> 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 <code>join()</code> 或 <code>append()</code> 来增加新列表，从而模拟出 <code>map-merge()</code> 的效果。</p><p>另一个实用的 Map 函数就是 <code>map-has-key()</code>，对于依赖 <code>map-get()</code> 的自定义函数来说，<code>map-has-key()</code> 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note unreleased">    <h5>Test Title</h5>    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p></div><p>虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;说一说js是什么语言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;javascript 是一种直译性脚本语言，是一种具备动态类型，弱类型，基于原型的语言。&lt;br&gt;它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最
      
    
    </summary>
    
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>个人简历</title>
    <link href="http://yoursite.com/2020/04/04/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    <id>http://yoursite.com/2020/04/04/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</id>
    <published>2020-04-03T16:00:00.000Z</published>
    <updated>2020-04-28T07:49:09.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="卓代丰"><a href="#卓代丰" class="headerlink" title="卓代丰"></a>卓代丰</h2><!-- ![](01.jpg) --><p>5年以上工作经验  |  大专学历  |  已离职-在岗<br>电话：13062352260    |   微信：13062352260</p><div class="note">    <h5>个人优势</h5>    <p>Personal advantage</p></div>    5年以上开发经验，架构前端项目，参与公司核心代码模块编写，谦虚谨慎，强烈的求知欲。了解web标准，熟悉大型网站页面架构和布局；深谙mv*思想，熟悉ES6新特性。    了解JAVA和node后台交互原理和代码实现，前端项目在服务器上的按照和部署。    目前技术栈为VUE+VUEX+AXIOS+VUE-ROUTER,UI框架使用的是iview<div class="note">    <h5>期望职位</h5>    <p>Position</p></div>职位：web前端开发 |  薪资：12k+(税后) |   工作地址：重庆     <div class="note">    <h5>工作经历</h5>    <p>Work experience</p></div><h4 id="安道亿联（重庆）供应链管理有限公司-（2017-03-）"><a href="#安道亿联（重庆）供应链管理有限公司-（2017-03-）" class="headerlink" title="安道亿联（重庆）供应链管理有限公司 （2017/03-）"></a>安道亿联（重庆）供应链管理有限公司 （2017/03-）</h4><p><em>开发部  /  前端组  /  web前端</em> </p><p>vue | css3 | sass | node | axios | echarts | 百度API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、独立完成系统架构设计进行系统架构设计工作;</span><br><span class="line">2、承担WEB前端核心模块的设计、实现工作;</span><br><span class="line">3、负责公司现有项目和新项目的前端修改调试和开发工作;</span><br><span class="line">4、对接服务端数据接口，将交互展示到项目中；</span><br></pre></td></tr></table></figure><h4 id="重庆元培科技有限公司-2016-01-2017-02"><a href="#重庆元培科技有限公司-2016-01-2017-02" class="headerlink" title="重庆元培科技有限公司 (2016/01-2017/02)"></a>重庆元培科技有限公司 (2016/01-2017/02)</h4><p><em>研发部  /  前端组 / web前端</em></p><p>html | javascript | backBone | ng1 | node | vue | css3 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">● 参与公司核心系统的开发；</span><br><span class="line">● 理解产品需求，参与产品功能的讨论，共同确定每次版本发布的功能点；</span><br><span class="line">● 分析产品功能，参与技术方案的讨论，并按照方案实现相关功能模块的开发；</span><br><span class="line">● 完成自己负责功能模块的单元测试，并协助测试人员进行UI和接口自动化测试。</span><br></pre></td></tr></table></figure><h4 id="重庆创扑科技有限公司-2014-09-2016-01"><a href="#重庆创扑科技有限公司-2014-09-2016-01" class="headerlink" title="重庆创扑科技有限公司 (2014/09-2016/01)"></a>重庆创扑科技有限公司 (2014/09-2016/01)</h4><p><em>研发部 / 程序员</em></p><p>Java | mysql | SSH | JQUERY | EXT.JS | JS | 其他  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">外包重庆电信渝北分公司，根据电信需求定制开发一些项目，</span><br><span class="line">主要从事手机前端，比如节日流量礼包等活动项目.</span><br><span class="line">此外，还在此期间完成公司壹教云，基于微信的学校管理平台。</span><br><span class="line">主要从事前端和部分后台。</span><br><span class="line">2015年11月至今，调回公司从事网站开发工作，在这几个月，</span><br><span class="line">完成了“天才足球”网站、“巴南民主村微官网”、“公司网站”等上线项目。</span><br><span class="line">此外微校园还在开发中···</span><br></pre></td></tr></table></figure><div class="note">    <h5>项目经历</h5>    <p>Project experience</p></div><h4 id="电力工程公司项目系统"><a href="#电力工程公司项目系统" class="headerlink" title="电力工程公司项目系统"></a>电力工程公司项目系统</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">角色：项目负责人</span><br><span class="line">该系统是为了规范电力工程公司员工作业而开发的一套智能识别+工程管理的系统。</span><br><span class="line">我们开发部主要任务是对员工的作业位置，监控记录，工作票的分配，项目人员的</span><br><span class="line">分配等进行开发。该系统分为三个子系统，视频管理系统，权限管理系统，erp管</span><br><span class="line">理系统。</span><br><span class="line">我的职责是带领前端人员对该系统基础构建，模块搭建，项目结构布局，核心模块编写</span><br><span class="line">操作系统：win7操作系统，node环境</span><br><span class="line">技术栈：HTML5+css3,es5,es6,高德地图API,AXIOS,VUE+IVIEW,Vue-router，</span><br><span class="line">其他类库和插件</span><br><span class="line">版本管理：git</span><br></pre></td></tr></table></figure><h4 id="重庆送变电智能考勤系统"><a href="#重庆送变电智能考勤系统" class="headerlink" title="重庆送变电智能考勤系统"></a>重庆送变电智能考勤系统</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">角色：项目负责人</span><br><span class="line">该系统是为送变电，工程公司员工专门打造的一款智能考勤系统，</span><br><span class="line">该系统使用人员在APP端进行打卡记录，地理位置记录，后端管理系统设置该考勤组人</span><br><span class="line">员打卡时间，打卡区域等等。</span><br><span class="line">在这个系统中我主要承担的角色是后台管理系统的搭建，公共组件核心模块的封装，以</span><br><span class="line">及系统核心考勤组模块的代码编写。</span><br><span class="line">涉及重难点，权限分配，考勤组打卡区域分配，区域定位，考勤组人员调动，打卡记录，</span><br><span class="line">excle定制化导出等</span><br><span class="line">操作系统：win7操作系统，node环境</span><br><span class="line">技术栈：HTML5+css3,es5,es6,高德地图API,AXIOS,VUE+IVIEW,Vue-router，</span><br><span class="line">其他类库和插件</span><br><span class="line">版本管理：git</span><br><span class="line">项目地址：http:&#x2F;&#x2F;kq.cqlanhui.com</span><br></pre></td></tr></table></figure><h4 id="干电力网"><a href="#干电力网" class="headerlink" title="干电力网"></a>干电力网</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">从事系统架构设计，技术选型，公共核心模块，组件的编写，从事WEB前端核心模块设计，</span><br><span class="line">编写。</span><br><span class="line">参与门户网，系统后台的页面编写，对接服务端数据接口，交互展示到浏览器中。</span><br><span class="line">该项目属于电力行业招聘信息网，面向全国推广，使用人数近百万。</span><br><span class="line">在该系统中，我的主要的工作内容是和产品了解需求，设计前端架构，开发核心模块，</span><br><span class="line">主导开发进度。</span><br><span class="line">开发环境：win7操作系统，node开发环境</span><br><span class="line">技术栈：JavaScript,css3,html5,jquery</span><br><span class="line">地址：http:&#x2F;&#x2F;kq.cqlanhui.com</span><br></pre></td></tr></table></figure><h4 id="小教室官网"><a href="#小教室官网" class="headerlink" title="小教室官网"></a>小教室官网</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">《小教室》是面向社会中小学生，在线考研，技能培训打造的一款在线学习的软件。</span><br><span class="line">可以同时在手机APP，PC端进行同步学习。该系统可进行一对一在线学习，也可大班</span><br><span class="line">教学。</span><br><span class="line">主要开发项目有：</span><br><span class="line">小教室http:&#x2F;&#x2F;www.xiaojs.cn前端开发，运用技术、HTML5+CSS3、jQuery、bootstrap、</span><br><span class="line">以及其他组件;</span><br><span class="line">小教室后台管理系统  开发环境NODE， 运用技术：HTML5+CSS3，bootstrap，jQuery，</span><br><span class="line">Vue。</span><br><span class="line">采用AMD模式模块化，组件化开发</span><br><span class="line">接口测试工具: postman</span><br><span class="line">项目地址：http:&#x2F;&#x2F;www.xiaojs.cn</span><br></pre></td></tr></table></figure><h4 id="lt-壹教云-gt-管理平台"><a href="#lt-壹教云-gt-管理平台" class="headerlink" title="&lt;壹教云&gt;管理平台"></a>&lt;壹教云&gt;管理平台</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这家公司属于外包和自营公司，白天在电信完成电信项目，比如节日送流量等活动，</span><br><span class="line">其他时间完成公司自营产品《壹教云》平台。 这个项目是属于微信+集成项目，</span><br><span class="line">可以查询到学生的进出情况，学生的生活学习情况等，该系统属于才开始研发阶段，</span><br><span class="line">我主要担任微信页面开发，和部分后台开发。</span><br><span class="line">主要用技术，Java，ssh,mySQL,HTML,JSP,JS,JQ,CSS3,JQ MOBIL</span><br><span class="line">版本管理 svn</span><br><span class="line">服务器：Tomcat</span><br><span class="line">项目地址：http:&#x2F;&#x2F;www.eyijiao.com&#x2F;</span><br></pre></td></tr></table></figure><div class="note">    <h5>教育经历</h5>    <p>Education experience</p></div><h4 id="重庆安全技术职业学院"><a href="#重庆安全技术职业学院" class="headerlink" title="重庆安全技术职业学院"></a>重庆安全技术职业学院</h4><p>全日制专科  |  计算机网络 |  2011-2013</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;卓代丰&quot;&gt;&lt;a href=&quot;#卓代丰&quot; class=&quot;headerlink&quot; title=&quot;卓代丰&quot;&gt;&lt;/a&gt;卓代丰&lt;/h2&gt;&lt;!-- ![](01.jpg) --&gt;
&lt;p&gt;5年以上工作经验  |  大专学历  |  已离职-在岗&lt;br&gt;电话：1306235226
      
    
    </summary>
    
    
    
      <category term="介绍" scheme="http://yoursite.com/tags/%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title>css nth选择器</title>
    <link href="http://yoursite.com/2020/04/02/typescript/"/>
    <id>http://yoursite.com/2020/04/02/typescript/</id>
    <published>2020-04-01T16:00:00.000Z</published>
    <updated>2020-04-02T10:54:36.003Z</updated>
    
    <content type="html"><![CDATA[<p>css 选择器非常丰富这将常用的记录一下</p><h2 id="选择前3个元素"><a href="#选择前3个元素" class="headerlink" title="选择前3个元素"></a>选择前3个元素</h2><p>渲染列表时，需要设置前3个元素的margin-top值与其他的不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:nth-child(-n+3)&#123;</span><br><span class="line">     margin-top: 12px;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody><tr><td><code>site</code></td><td>Sitewide information.</td></tr><tr><td><code>page</code></td><td>Page specific information and custom variables set in front-matter.</td></tr><tr><td><code>config</code></td><td>Site configuration</td></tr><tr><td><code>theme</code></td><td>Theme configuration. Inherits from site configuration.</td></tr><tr><td><code>_</code> (single underscore)</td><td><a href="http://lodash.com/" target="_blank" rel="noopener">Lodash</a> library</td></tr><tr><td><code>path</code></td><td>Path of current page</td></tr><tr><td><code>url</code></td><td>Full URL of current page</td></tr><tr><td><code>env</code></td><td>Environment variables</td></tr></tbody></table><h2 id="语法比较"><a href="#语法比较" class="headerlink" title="语法比较"></a>语法比较</h2><div class="note">    <h5>测试标题</h5>    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。</p></div><h4 id="Map-语法"><a href="#Map-语法" class="headerlink" title="Map 语法"></a>Map 语法</h4><p>下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-map: (</span><br><span class="line">    small: (</span><br><span class="line">        min-width: null,</span><br><span class="line">        max-width: 479px,</span><br><span class="line">        base-font: 16px,</span><br><span class="line">        vertical-rhythm: 1.3</span><br><span class="line">    ),</span><br><span class="line">    medium: (</span><br><span class="line">        min-width: 480px,</span><br><span class="line">        max-width: 959px,</span><br><span class="line">        base-font: 18px,</span><br><span class="line">        vertical-rhythm: 1.414</span><br><span class="line">    ),</span><br><span class="line">    large: (</span><br><span class="line">        min-width: 960px,</span><br><span class="line">        max-width: 1099px,</span><br><span class="line">        base-font: 18px,</span><br><span class="line">        vertical-rhythm: 1.5</span><br><span class="line">    ),</span><br><span class="line">    xlarge: (</span><br><span class="line">        min-width: 1100px,</span><br><span class="line">        max-width: null,</span><br><span class="line">        base-font: 21px,</span><br><span class="line">        vertical-rhythm: 1.618</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="多重列表语法"><a href="#多重列表语法" class="headerlink" title="多重列表语法"></a>多重列表语法</h4><p>下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 <code>nth()</code> 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-list: (</span><br><span class="line">    (small, null, 479px, 16px, 1.3),</span><br><span class="line">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class="line">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class="line">    (xlarge, 1100px, null, 21px, 1.618)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="遍历比较"><a href="#遍历比较" class="headerlink" title="遍历比较"></a>遍历比较</h2><div class="note info">    <h5>测试标题</h5>    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p></div><h4 id="遍历-Map"><a href="#遍历-Map" class="headerlink" title="遍历 Map"></a>遍历 Map</h4><p>我们可以使用如下的代码遍历 Map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $map in $breakpoint-map &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里的变量 <code>$label</code> 和 <code>$map</code> 会随着对 <code>$breakpoint-map</code> 的遍历被动态地赋值，<code>$label</code> 将会被赋值为 <code>$breakpoint-map</code> 的 Key，而 <code>$map</code> 会被赋值为 <code>$breakpoint-map</code> 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 <code>map-get()</code> 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。</p><p>具体的做法就是使用 <code>@each</code> 遍历 Map，然后使用 <code>map-get()</code> 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $map in $breakpoint-map &#123;</span><br><span class="line">    $min-width: map-get($map, min-width);</span><br><span class="line">    $max-width: map-get($map, max-width);</span><br><span class="line">    $base-font: map-get($map, base-font);</span><br><span class="line">    $vertical-rhythm: map-get($map, vertical-rhythm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历多重列表"><a href="#遍历多重列表" class="headerlink" title="遍历多重列表"></a>遍历多重列表</h4><p>遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 <code>map-get()</code> 函数取特定值，直接遍历一遍即可获得特定值。</p><p>因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 <code>map-get()</code>，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="慎用多重列表"><a href="#慎用多重列表" class="headerlink" title="慎用多重列表"></a>慎用多重列表</h2><div class="note warning">    <h5>测试标题</h5>    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p></div><h4 id="遗漏键值"><a href="#遗漏键值" class="headerlink" title="遗漏键值"></a>遗漏键值</h4><p>如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-list: (</span><br><span class="line">    (small, null, 479px, 16px, 1.3),</span><br><span class="line">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class="line">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class="line">    (xlarge, 1100px, 21px, 1.618)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class="line">        @if $min-width &#123;</span><br><span class="line">            @include breakpoint( $min-width ) &#123;</span><br><span class="line">                font-size: $base-font;</span><br><span class="line">                line-height: $vertical-rhythm;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; @else &#123;</span><br><span class="line">            font-size: $base-font;</span><br><span class="line">            line-height: $vertical-rhythm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们尝试运行这段代码时，结果肯定是错误地，因为在 <code>$breakpoint-list</code> 的最后一行，<code>xlarge</code> 被赋值给了 <code>$label</code>，<code>1100px</code> 被赋值给了 <code>$min-width</code>，<code>21px</code> 被赋值给了 <code>$max-width</code>, <code>1.618</code> 被赋值给了 <code>$base-font</code>，最终导致 <code>$vertical-rhythm</code> 没有被赋值，结果就是 <code>font-size</code> 的属性值是错的，<code>line-height</code> 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。</p><p>如果我们使用 Map 来代替这里的多重列表，那么使用 <code>map-get()</code> 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。</p><h4 id="查找特定列表"><a href="#查找特定列表" class="headerlink" title="查找特定列表"></a>查找特定列表</h4><p>在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 <code>map-get()</code> 函数可以快速定位到特定子 Map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$medium-map: map-get($maps, medium);</span><br></pre></td></tr></table></figure><p>但如果要获取多种列表 <code>medium</code> 列表，麻烦可就大了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@function get-list($label) &#123;</span><br><span class="line">    @each $list in $breakpoint-list &#123;</span><br><span class="line">        @if nth($list, 1) &#x3D;&#x3D; $label &#123;</span><br><span class="line">            @return $list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @return null;</span><br><span class="line">&#125;</span><br><span class="line">$medium-list: get-list(medium);</span><br></pre></td></tr></table></figure><p>这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 <code>null</code>。这实际上就是手工实现了 <code>map-get()</code> 的逻辑。</p><h4 id="缺少原生的-Map-函数"><a href="#缺少原生的-Map-函数" class="headerlink" title="缺少原生的 Map 函数"></a>缺少原生的 Map 函数</h4><p>Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 <code>map-merge()</code> 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 <code>join()</code> 或 <code>append()</code> 来增加新列表，从而模拟出 <code>map-merge()</code> 的效果。</p><p>另一个实用的 Map 函数就是 <code>map-has-key()</code>，对于依赖 <code>map-get()</code> 的自定义函数来说，<code>map-has-key()</code> 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note unreleased">    <h5>Test Title</h5>    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p></div><p>虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;css 选择器非常丰富这将常用的记录一下&lt;/p&gt;
&lt;h2 id=&quot;选择前3个元素&quot;&gt;&lt;a href=&quot;#选择前3个元素&quot; class=&quot;headerlink&quot; title=&quot;选择前3个元素&quot;&gt;&lt;/a&gt;选择前3个元素&lt;/h2&gt;&lt;p&gt;渲染列表时，需要设置前3个元素的margin
      
    
    </summary>
    
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>辨析 Sass 中的 Map 和 List111</title>
    <link href="http://yoursite.com/2015/10/21/demo/"/>
    <id>http://yoursite.com/2015/10/21/demo/</id>
    <published>2015-10-21T02:34:12.000Z</published>
    <updated>2020-04-02T07:25:35.789Z</updated>
    
    <content type="html"><![CDATA[<p>如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。</p><p>自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。</p><p>那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 <code>package.json</code> 或者其他同类型的项目配置文件所控制，往往只需一条命令（<code>gem update sass</code>）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。</p><a id="more"></a><p>使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。</p><h2 id="测试表格"><a href="#测试表格" class="headerlink" title="测试表格"></a>测试表格</h2><table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody><tr><td><code>site</code></td><td>Sitewide information.</td></tr><tr><td><code>page</code></td><td>Page specific information and custom variables set in front-matter.</td></tr><tr><td><code>config</code></td><td>Site configuration</td></tr><tr><td><code>theme</code></td><td>Theme configuration. Inherits from site configuration.</td></tr><tr><td><code>_</code> (single underscore)</td><td><a href="http://lodash.com/" target="_blank" rel="noopener">Lodash</a> library</td></tr><tr><td><code>path</code></td><td>Path of current page</td></tr><tr><td><code>url</code></td><td>Full URL of current page</td></tr><tr><td><code>env</code></td><td>Environment variables</td></tr></tbody></table><h2 id="语法比较"><a href="#语法比较" class="headerlink" title="语法比较"></a>语法比较</h2><div class="note">    <h5>测试标题</h5>    <p>在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。</p></div><h4 id="Map-语法"><a href="#Map-语法" class="headerlink" title="Map 语法"></a>Map 语法</h4><p>下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-map: (</span><br><span class="line">    small: (</span><br><span class="line">        min-width: null,</span><br><span class="line">        max-width: 479px,</span><br><span class="line">        base-font: 16px,</span><br><span class="line">        vertical-rhythm: 1.3</span><br><span class="line">    ),</span><br><span class="line">    medium: (</span><br><span class="line">        min-width: 480px,</span><br><span class="line">        max-width: 959px,</span><br><span class="line">        base-font: 18px,</span><br><span class="line">        vertical-rhythm: 1.414</span><br><span class="line">    ),</span><br><span class="line">    large: (</span><br><span class="line">        min-width: 960px,</span><br><span class="line">        max-width: 1099px,</span><br><span class="line">        base-font: 18px,</span><br><span class="line">        vertical-rhythm: 1.5</span><br><span class="line">    ),</span><br><span class="line">    xlarge: (</span><br><span class="line">        min-width: 1100px,</span><br><span class="line">        max-width: null,</span><br><span class="line">        base-font: 21px,</span><br><span class="line">        vertical-rhythm: 1.618</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="多重列表语法"><a href="#多重列表语法" class="headerlink" title="多重列表语法"></a>多重列表语法</h4><p>下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 <code>nth()</code> 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-list: (</span><br><span class="line">    (small, null, 479px, 16px, 1.3),</span><br><span class="line">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class="line">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class="line">    (xlarge, 1100px, null, 21px, 1.618)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="遍历比较"><a href="#遍历比较" class="headerlink" title="遍历比较"></a>遍历比较</h2><div class="note info">    <h5>测试标题</h5>    <p>从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？</p></div><h4 id="遍历-Map"><a href="#遍历-Map" class="headerlink" title="遍历 Map"></a>遍历 Map</h4><p>我们可以使用如下的代码遍历 Map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $map in $breakpoint-map &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里的变量 <code>$label</code> 和 <code>$map</code> 会随着对 <code>$breakpoint-map</code> 的遍历被动态地赋值，<code>$label</code> 将会被赋值为 <code>$breakpoint-map</code> 的 Key，而 <code>$map</code> 会被赋值为 <code>$breakpoint-map</code> 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 <code>map-get()</code> 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。</p><p>具体的做法就是使用 <code>@each</code> 遍历 Map，然后使用 <code>map-get()</code> 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $map in $breakpoint-map &#123;</span><br><span class="line">    $min-width: map-get($map, min-width);</span><br><span class="line">    $max-width: map-get($map, max-width);</span><br><span class="line">    $base-font: map-get($map, base-font);</span><br><span class="line">    $vertical-rhythm: map-get($map, vertical-rhythm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历多重列表"><a href="#遍历多重列表" class="headerlink" title="遍历多重列表"></a>遍历多重列表</h4><p>遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 <code>map-get()</code> 函数取特定值，直接遍历一遍即可获得特定值。</p><p>因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 <code>map-get()</code>，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="慎用多重列表"><a href="#慎用多重列表" class="headerlink" title="慎用多重列表"></a>慎用多重列表</h2><div class="note warning">    <h5>测试标题</h5>    <p>经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。</p></div><h4 id="遗漏键值"><a href="#遗漏键值" class="headerlink" title="遗漏键值"></a>遗漏键值</h4><p>如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$breakpoint-list: (</span><br><span class="line">    (small, null, 479px, 16px, 1.3),</span><br><span class="line">    (medium, 480px, 959px, 18px, 1.414),</span><br><span class="line">    (large, 960px, 1099px, 18px, 1.5),</span><br><span class="line">    (xlarge, 1100px, 21px, 1.618)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">    @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;</span><br><span class="line">        @if $min-width &#123;</span><br><span class="line">            @include breakpoint( $min-width ) &#123;</span><br><span class="line">                font-size: $base-font;</span><br><span class="line">                line-height: $vertical-rhythm;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; @else &#123;</span><br><span class="line">            font-size: $base-font;</span><br><span class="line">            line-height: $vertical-rhythm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们尝试运行这段代码时，结果肯定是错误地，因为在 <code>$breakpoint-list</code> 的最后一行，<code>xlarge</code> 被赋值给了 <code>$label</code>，<code>1100px</code> 被赋值给了 <code>$min-width</code>，<code>21px</code> 被赋值给了 <code>$max-width</code>, <code>1.618</code> 被赋值给了 <code>$base-font</code>，最终导致 <code>$vertical-rhythm</code> 没有被赋值，结果就是 <code>font-size</code> 的属性值是错的，<code>line-height</code> 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。</p><p>如果我们使用 Map 来代替这里的多重列表，那么使用 <code>map-get()</code> 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。</p><h4 id="查找特定列表"><a href="#查找特定列表" class="headerlink" title="查找特定列表"></a>查找特定列表</h4><p>在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 <code>map-get()</code> 函数可以快速定位到特定子 Map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$medium-map: map-get($maps, medium);</span><br></pre></td></tr></table></figure><p>但如果要获取多种列表 <code>medium</code> 列表，麻烦可就大了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@function get-list($label) &#123;</span><br><span class="line">    @each $list in $breakpoint-list &#123;</span><br><span class="line">        @if nth($list, 1) &#x3D;&#x3D; $label &#123;</span><br><span class="line">            @return $list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @return null;</span><br><span class="line">&#125;</span><br><span class="line">$medium-list: get-list(medium);</span><br></pre></td></tr></table></figure><p>这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 <code>null</code>。这实际上就是手工实现了 <code>map-get()</code> 的逻辑。</p><h4 id="缺少原生的-Map-函数"><a href="#缺少原生的-Map-函数" class="headerlink" title="缺少原生的 Map 函数"></a>缺少原生的 Map 函数</h4><p>Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 <code>map-merge()</code> 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 <code>join()</code> 或 <code>append()</code> 来增加新列表，从而模拟出 <code>map-merge()</code> 的效果。</p><p>另一个实用的 Map 函数就是 <code>map-has-key()</code>，对于依赖 <code>map-get()</code> 的自定义函数来说，<code>map-has-key()</code> 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note unreleased">    <h5>Test Title</h5>    <p>相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。</p></div><p>虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。&lt;/p&gt;
&lt;p&gt;自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。&lt;/p&gt;
&lt;p&gt;那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 &lt;code&gt;package.json&lt;/code&gt; 或者其他同类型的项目配置文件所控制，往往只需一条命令（&lt;code&gt;gem update sass&lt;/code&gt;）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
</feed>
